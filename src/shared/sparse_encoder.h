#ifndef SPARSE_ENCODER_H
#define SPARSE_ENCODER_H

#include "srgrammar.h"
#include "sparse.h"

#include <assert.h> // @@@m

////////////////////////////////////////////////////////////////////////////

/**
 * Class that performs the mapping between template logical names available to the user and their internal indexes.
 */
class TemplateTypeDefinition{
    
    public:
    TemplateTypeDefinition(){};
    TemplateTypeDefinition(vector<PSTRING> const &colnames);
    TemplateTypeDefinition(TemplateTypeDefinition const &other);
    TemplateTypeDefinition& operator=(TemplateTypeDefinition const &other);
    
    int operator()(PSTRING const &colname)const;
    bool operator==(TemplateTypeDefinition const &other)const;
    
    PSTRING get_colname(int idx)const;
    
    void load(string const &filename);
    void save(string const &filename)const;
    
    private:
    vector<PSTRING> colnames;
};



//Templates
class FeatureSensor{

 public:
  virtual TOK_CODE get_value(StateSignature const &signature)const = 0;
  virtual FeatureSensor* clone()const = 0;
  virtual ~FeatureSensor(){};

  virtual int get_colidx() = 0;
    
  virtual bool do_sanity_check()const = 0;

  virtual PSTRING toString(TemplateTypeDefinition const &ttd)const = 0;

 protected:
  TOK_CODE undefined_left;
  TOK_CODE undefined_right;

  virtual TOK_CODE get_lex_value(int tok_idx, int token_field,StateSignature const &signature)const;
  virtual void set_undefined_values(int colidx);

};


class StackFeatureSensor : public FeatureSensor{

 public:
  enum ITEM_POS {TOP,LEFT,RIGHT,LC,RC};//top, left, right, left corner,right corner
  enum ITEM_FIELD {HEAD_WORD,CATEGORY};

  StackFeatureSensor();

  //for category value retrieval
  StackFeatureSensor(unsigned int stack_idx,ITEM_POS posn);
  
  //for head word value retrieval
  StackFeatureSensor(unsigned int stack_idx,ITEM_POS posn,int token_field);
  
  //copy
  StackFeatureSensor(const StackFeatureSensor &other);
  StackFeatureSensor& operator=(const StackFeatureSensor &other);
  StackFeatureSensor* clone()const;

  //main method
  TOK_CODE get_value(StateSignature const &signature)const;
    
  virtual int get_colidx(){return token_field + 1;}

  bool do_sanity_check()const;

  PSTRING toString(TemplateTypeDefinition const &ttd)const;

 protected:
  unsigned int stack_idx;
  ITEM_POS posn;
  ITEM_FIELD field;
  int token_field;
  
};

class QueueFeatureSensor :  public FeatureSensor{
 
public:
  QueueFeatureSensor();
  QueueFeatureSensor(unsigned int queue_shift,int token_field);
  QueueFeatureSensor(const QueueFeatureSensor &other);
  QueueFeatureSensor& operator=(const QueueFeatureSensor &other);
  QueueFeatureSensor* clone()const;

  TOK_CODE get_value(StateSignature const &signature)const;

  virtual int get_colidx(){return token_field + 1;}
  bool do_sanity_check()const{return true;};

  PSTRING toString(TemplateTypeDefinition const &ttd)const;

    
protected:
  unsigned int queue_idx;
  int token_field;
};

class FeatureTemplate{

public:

  FeatureTemplate();
  FeatureTemplate(unsigned int tpl_idx);
    
  FeatureTemplate(wstring const &template_line,TemplateTypeDefinition const &ttd); //builds a template from a line of the form T(1) =  s0(t,h,tag) & s1(t,h,tag)
    
  FeatureTemplate(const FeatureTemplate &other);
  FeatureTemplate& operator=(const FeatureTemplate &other);
  ~FeatureTemplate();

  void add_sensor(FeatureSensor *sensor);

  //gets the index of the 1 valued feature generated by this template in the dense feature vector
  unsigned int get_index(StateSignature const &signature)const;

  unsigned int get_index_in_lookup(StateSignature const &signature){
      assert(sensors.size() == 1);
      return sensors[0]->get_value(signature);
  }
  int get_colidx(){return sensors.at(0)->get_colidx();}

  unsigned int get_template_idx()const{return template_idx;}
    
  //checks if the template tries to address illegal values on the stack.
  bool do_sanity_check()const;
  
  //stores a template tpl from buffer,returns false when no template
  static bool get_template(wistream &instream,FeatureTemplate &tpl,TemplateTypeDefinition const &ttd);
  
  bool has_morpho()const{return morpho;}
    
  PSTRING toString(TemplateTypeDefinition const &ttd)const;
    
protected:
    
  bool get_morpho(wstring const &tpl_lhs)const;
  
    
  vector<FeatureSensor*> sensors;
  unsigned int S;
  unsigned int template_idx;
  FeatureIndexer indexer;
  AbstractFeature feature_signature;
  void clear_sensors();
  bool morpho = false;
};



/**
 * Encodes a configuration on a sparse Phi(x) vector
 */
class SparseEncoder{
 
 public:
    
  SparseEncoder();
  SparseEncoder(string const &filename,TemplateTypeDefinition const &ttd);
  SparseEncoder(const char *filename,TemplateTypeDefinition const &ttd);
  SparseEncoder(const SparseEncoder &other);
  SparseEncoder& operator=(const SparseEncoder &other);

  void add_template(FeatureTemplate const &ntemplate);
  
  bool has_morpho()const{return morpho;};//says if morph templates are defined
    
    
  //Encodes a configuration on a sparse Phi(x) vector (encoding param)
  //if the clear param is set to true, erases the content of the encoding vector prior to encoding the signature
  void encode(vector<unsigned int> &encoding,StateSignature const &signature,bool clear=true)const;
  void encode(SparseFloatVector &encoding,StateSignature const &signature,bool clear=true)const;

  size_t ntemplates()const{return templates.size();};

  //saves templates to file
  void save(string const &filename)const;

  //tests if the templates :
  //    - have duplicate IDs
  //    - try to adress information not available from the stack
  // in case of failure,it aborts the execution and reports an error message
  bool do_sanity_check()const;
    
  PSTRING toString(TemplateTypeDefinition const &ttd)const;
  void save(const char *filename,TemplateTypeDefinition const &ttd)const;
    
private:
  vector<FeatureTemplate> templates;
  unsigned int T;
  bool morpho = false;
};

///////////////////////////////////////////////////////////////////////
#endif
